/*! MIT License - Copyright (c) 2021 Samarium */(function(){"use strict";var n={719:function(n,e,t){var a=t(9963),i=t(6252);function r(n,e,t,a,r,o){const s=(0,i.up)("router-view");return(0,i.wg)(),(0,i.j4)(s)}var o=(0,i.aZ)({name:"App"}),s=t(3744);const m=(0,s.Z)(o,[["render",r]]);var d=m,u=t(2119),c='#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n"""\nCreate \'mirage tank\' images in Python\nPart of the code adapted from https://www.cnblogs.com/sryml/p/10970270.html\n"""\nimport time\nfrom typing import Callable\n\nimport cv2\nimport numpy as np\nfrom numba import njit\n\n\ndef profile(func: Callable) -> Callable:\n    """\n    A decorator function for elapsed-time profiling\n\n    usage: @profile\n\n    :param func: function to profile\n    """\n\n    def with_profiling(*args, **kwargs):\n        start_time = time.time()\n        ret = func(*args, **kwargs)\n        elapsed_time = time.time() - start_time\n        print(\'{} finished, takes {:.4f}s\'.format(func.__name__, elapsed_time))\n        return ret\n\n    return with_profiling\n\n\n@profile\ndef desaturate(image: np.ndarray) -> np.ndarray:\n    """\n    Photoshop-like desaturation, formula:\n\n    lambda r, g, b: (max(r, g, b) + min(r, g, b)) / 2\n\n    source: https://stackoverflow.com/a/28873770\n\n    :param image: input RGB image read by cv2\n    :return: desaturated grayscale image\n    """\n    cp: np.ndarray = image.copy().astype(np.float_)\n    desaturated: np.ndarray = (np.amax(cp, 2) + np.amin(cp, 2)) / 2\n    return desaturated.astype(np.uint8)\n\n\n@profile\ndef adjust_lightness(image: np.ndarray, ratio: float) -> np.ndarray:\n    """\n    Adjust the lightness of the image\n\n    :param image: input grayscale image\n    :param ratio: float number from -100% to +100%\n    :return: adjusted image\n    """\n    cp: np.ndarray = image.copy().astype(np.float_)\n    if ratio > 0:\n        return (cp * (1 - ratio) + 255 * ratio).astype(np.uint8)\n    return np.ceil(cp * (1 + ratio)).astype(np.uint8)\n\n\n@profile\ndef invert(image: np.ndarray) -> np.ndarray:\n    """\n    Invert the color of the image\n\n    :param image: input grayscale image\n    :return: inverted image\n    """\n    return 255 - image\n\n\n@profile\ndef linear_dodge_blend(img_x: np.ndarray, img_y: np.ndarray) -> np.ndarray:\n    """\n    Blend image x and y in \'linear dodge\' mode\n\n    :param img_x: input grayscale image on top\n    :param img_y: input grayscale image at bottom\n    :return:\n    """\n    return img_x + img_y\n\n\n@profile\n@njit\ndef divide_blend(img_x: np.ndarray, img_y: np.ndarray) -> np.ndarray:\n    """\n    Blend image x and y in \'divide\' mode\n\n    :param img_x: input grayscale image on top\n    :param img_y: input grayscale image at bottom\n    :return:\n    """\n    result = np.zeros_like(img_x, np.float_)\n    height, width = img_x.shape\n    for i in range(height):\n        for j in range(width):\n            if img_x[i, j] == 0:\n                color = img_y[i, j] and 255 or 0\n            elif img_x[i, j] == 255:\n                color = img_y[i, j]\n            elif img_x[i, j] == img_y[i, j]:\n                color = 255\n            else:\n                color = (img_y[i, j] / img_x[i, j]) * 255\n            result[i, j] = color\n    return result.astype(np.uint8)\n\n\n@profile\ndef add_mask(img_x: np.ndarray, img_y: np.ndarray) -> np.ndarray:\n    """\n    Add image y to x as the alpha channel\n\n    :param img_x: input grayscale image\n    :param img_y: input grayscale image\n    :return: the result image\n    """\n    result: np.ndarray = cv2.cvtColor(img_x, cv2.COLOR_GRAY2BGRA)\n    result[:, :, 3] = img_y\n    return result\n\n\ndef build(source_x: str, source_y: str, target_name: str, shrink: float = 1):\n    """\n    Build a \'mirage tank\' image from [source_x] and [source_y]\n\n    (Assuming [source_x] and [source_y] have the same size)\n\n    :param source_x: name of the image shown on white background\n    :param source_y: name of the image shown on black background\n    :param target_name: name of the image to be saved\n    :param shrink: size change comparing to the source image\n    """\n    print("start process")\n    img_a = cv2.cvtColor(\n        cv2.imread(source_x, cv2.IMREAD_UNCHANGED),\n        cv2.COLOR_BGR2RGB\n    )\n    img_b = cv2.cvtColor(\n        cv2.imread(source_y, cv2.IMREAD_UNCHANGED),\n        cv2.COLOR_BGR2RGB\n    )\n    height, width, _ = img_a.shape\n    height = int(height * shrink)\n    width = int(width * shrink)\n    img_a = invert(\n        adjust_lightness(desaturate(cv2.resize(img_a, (width, height))), 0.5)\n    )\n    img_b = adjust_lightness(\n        desaturate(cv2.resize(img_b, (width, height))), -0.5\n    )\n    linear_dodged = linear_dodge_blend(img_a, img_b)\n    divided = divide_blend(linear_dodged, img_b)\n    cv2.imwrite(target_name, add_mask(divided, linear_dodged))\n    print("finished")\n',p='import _defineProperty from "/home/runner/work/mirage-tank-images/mirage-tank-images/node_modules/@babel/runtime/helpers/esm/defineProperty.js";\nimport "core-js/modules/es.typed-array.at.js";\nimport "core-js/modules/es.typed-array.set.js";\nimport "core-js/modules/es.error.cause.js";\nimport Jimp from "jimp/browser/lib/jimp.js";\nimport ab2b from "arraybuffer-to-buffer";\nimport * as mjs from "mathjs";\n\nclass MirageTankImage {\n  constructor(image) {\n    _defineProperty(this, "width", void 0);\n\n    _defineProperty(this, "height", void 0);\n\n    _defineProperty(this, "channel", void 0);\n\n    _defineProperty(this, "data", void 0);\n\n    if (image instanceof Jimp) {\n      image = image;\n      this.width = image.bitmap.width;\n      this.height = image.bitmap.height;\n      const matrix = mjs.zeros([this.height, this.width, 3], "dense");\n      image.scan(0, 0, image.bitmap.width, image.bitmap.height, function (x, y, index) {\n        matrix.set([y, x, 0], this.bitmap.data[index]);\n        matrix.set([y, x, 1], this.bitmap.data[index] + 1);\n        matrix.set([y, x, 2], this.bitmap.data[index] + 2);\n      });\n      this.data = matrix;\n      this.channel = 3;\n    } else {\n      image = image;\n      const size = image.size();\n      this.width = size[1];\n      this.height = size[0];\n      this.channel = size[2];\n      this.data = image;\n    }\n  }\n\n  getData() {\n    return this.data;\n  }\n\n  desaturate() {\n    this.data = mjs.divide(mjs.add(mjs.max(this.data, 2), mjs.min(this.data, 2)), 2);\n    this.channel = 1;\n  }\n\n  invert() {\n    this.data = mjs.subtract(255, this.data);\n  }\n\n  adjustLightness(ratio) {\n    if (ratio > 0) {\n      this.data = mjs.add(mjs.multiply(this.data, 1 - ratio), 255 * ratio);\n    } else {\n      this.data = mjs.multiply(this.data, 1 + ratio);\n    }\n  }\n\n  linearDodgeBlend(image) {\n    this.data = mjs.add(this.data, image.getData());\n  }\n\n  divideBlend(image) {\n    const result = mjs.zeros([this.height, this.width], "dense");\n    /* eslint-disable @typescript-eslint/ban-ts-comment */\n    // @ts-ignore\n\n    this.data.forEach((value, index) => {\n      const i = mjs.index(...index); // @ts-ignore\n\n      const mix = this.data.subset(i); // @ts-ignore\n\n      const base = image.getData().subset(i);\n      let color;\n\n      switch (mix) {\n        case 0:\n          color = base === 0 ? 0 : 255;\n          break;\n\n        case 255:\n          color = base;\n          break;\n\n        case base:\n          color = 255;\n          break;\n\n        default:\n          color = mjs.round(base / mix * 255);\n      }\n\n      result.set([...index], color);\n    });\n    /* eslint-enable @typescript-eslint/ban-ts-comment */\n\n    this.data = result;\n  }\n\n  clone() {\n    return new MirageTankImage(this.data.clone());\n  }\n\n  toRGBA(data) {\n    /* eslint-disable @typescript-eslint/ban-ts-comment */\n    // @ts-ignore\n    this.data = this.data.map((value, index) => {\n      value = mjs.round(value);\n\n      if (value > 255) {\n        value = 255;\n      }\n\n      if (value < 0) {\n        value = 0;\n      } // @ts-ignore\n\n\n      const alpha = data ? data.subset(mjs.index(...index)) : 255;\n      return [value, value, value, alpha];\n    });\n    /* eslint-enable @typescript-eslint/ban-ts-comment */\n\n    this.channel = 4;\n  }\n\n  toUint8Array() {\n    return new Uint8Array(this.data.toArray().flat(2));\n  }\n\n}\n\nexport async function buildImage(top, bottom) {\n  const topImage = await Jimp.read(ab2b(top));\n  const bottomImage = await Jimp.read(ab2b(bottom));\n  return new Promise((resolve, reject) => {\n    if (topImage.bitmap.width !== bottomImage.bitmap.width || topImage.bitmap.height !== bottomImage.bitmap.height) reject(new Error("not same size"));\n    const top = new MirageTankImage(topImage);\n    const bottom = new MirageTankImage(bottomImage);\n    top.desaturate();\n    bottom.desaturate();\n    top.adjustLightness(0.5);\n    bottom.adjustLightness(-0.5);\n    top.invert();\n    top.linearDodgeBlend(bottom);\n    const linearDodged = top.clone();\n    top.divideBlend(bottom);\n    top.toRGBA(linearDodged.getData());\n    const result = new Jimp({\n      data: top.toUint8Array(),\n      width: topImage.bitmap.width,\n      height: topImage.bitmap.height\n    });\n    resolve(result.getBase64Async(Jimp.MIME_PNG));\n  });\n}';const l={python:{code:c,language:"python"},typescript:{code:p,language:"typescript"}};var g=l,h=(0,u.p7)({history:(0,u.PO)("/mirage-tank-images/"),routes:[{path:"/",name:"Home",component:()=>t.e(840).then(t.bind(t,6840)),children:[{path:"",name:"Descriptions",component:()=>t.e(463).then(t.bind(t,4344))},{path:"builder",name:"Builder",component:()=>t.e(18).then(t.bind(t,3018))},{path:"algorithm",name:"Algorithm",component:()=>t.e(162).then(t.bind(t,6162))},{path:"code",redirect:{name:"Python"}},{path:"code/python",name:"Python",component:()=>t.e(534).then(t.bind(t,534)),props:g.python},{path:"code/typescript",name:"TypeScript",component:()=>t.e(534).then(t.bind(t,534)),props:g.typescript}]}]}),f=t(7308),b=t(4499);t(2467);(0,a.ri)(d).use(b.ZP).use(f.Z).use(h).mount("#app")}},e={};function t(a){var i=e[a];if(void 0!==i)return i.exports;var r=e[a]={exports:{}};return n[a].call(r.exports,r,r.exports,t),r.exports}t.m=n,function(){var n=[];t.O=function(e,a,i,r){if(!a){var o=1/0;for(u=0;u<n.length;u++){a=n[u][0],i=n[u][1],r=n[u][2];for(var s=!0,m=0;m<a.length;m++)(!1&r||o>=r)&&Object.keys(t.O).every((function(n){return t.O[n](a[m])}))?a.splice(m--,1):(s=!1,r<o&&(o=r));if(s){n.splice(u--,1);var d=i();void 0!==d&&(e=d)}}return e}r=r||0;for(var u=n.length;u>0&&n[u-1][2]>r;u--)n[u]=n[u-1];n[u]=[a,i,r]}}(),function(){t.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return t.d(e,{a:e}),e}}(),function(){var n,e=Object.getPrototypeOf?function(n){return Object.getPrototypeOf(n)}:function(n){return n.__proto__};t.t=function(a,i){if(1&i&&(a=this(a)),8&i)return a;if("object"===typeof a&&a){if(4&i&&a.__esModule)return a;if(16&i&&"function"===typeof a.then)return a}var r=Object.create(null);t.r(r);var o={};n=n||[null,e({}),e([]),e(e)];for(var s=2&i&&a;"object"==typeof s&&!~n.indexOf(s);s=e(s))Object.getOwnPropertyNames(s).forEach((function(n){o[n]=function(){return a[n]}}));return o["default"]=function(){return a},t.d(r,o),r}}(),function(){t.d=function(n,e){for(var a in e)t.o(e,a)&&!t.o(n,a)&&Object.defineProperty(n,a,{enumerable:!0,get:e[a]})}}(),function(){t.f={},t.e=function(n){return Promise.all(Object.keys(t.f).reduce((function(e,a){return t.f[a](n,e),e}),[]))}}(),function(){t.u=function(n){return"js/"+n+"."+{18:"e3392d99",162:"24cc9be0",463:"af6fcf71",534:"3bfd85eb",558:"9befa20a",840:"5928d2b7",968:"9984e33a"}[n]+".js"}}(),function(){t.miniCssF=function(n){return"css/"+n+"."+{18:"c37d0700",162:"fa5f0f86",463:"8c53f9af",534:"11cfc769",840:"d97b741a"}[n]+".css"}}(),function(){t.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"===typeof window)return window}}()}(),function(){t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)}}(),function(){var n={},e="mirage-tank-images:";t.l=function(a,i,r,o){if(n[a])n[a].push(i);else{var s,m;if(void 0!==r)for(var d=document.getElementsByTagName("script"),u=0;u<d.length;u++){var c=d[u];if(c.getAttribute("src")==a||c.getAttribute("data-webpack")==e+r){s=c;break}}s||(m=!0,s=document.createElement("script"),s.charset="utf-8",s.timeout=120,t.nc&&s.setAttribute("nonce",t.nc),s.setAttribute("data-webpack",e+r),s.src=a),n[a]=[i];var p=function(e,t){s.onerror=s.onload=null,clearTimeout(l);var i=n[a];if(delete n[a],s.parentNode&&s.parentNode.removeChild(s),i&&i.forEach((function(n){return n(t)})),e)return e(t)},l=setTimeout(p.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=p.bind(null,s.onerror),s.onload=p.bind(null,s.onload),m&&document.head.appendChild(s)}}}(),function(){t.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}}(),function(){t.p="/mirage-tank-images/"}(),function(){var n=function(n,e,t,a){var i=document.createElement("link");i.rel="stylesheet",i.type="text/css";var r=function(r){if(i.onerror=i.onload=null,"load"===r.type)t();else{var o=r&&("load"===r.type?"missing":r.type),s=r&&r.target&&r.target.href||e,m=new Error("Loading CSS chunk "+n+" failed.\n("+s+")");m.code="CSS_CHUNK_LOAD_FAILED",m.type=o,m.request=s,i.parentNode.removeChild(i),a(m)}};return i.onerror=i.onload=r,i.href=e,document.head.appendChild(i),i},e=function(n,e){for(var t=document.getElementsByTagName("link"),a=0;a<t.length;a++){var i=t[a],r=i.getAttribute("data-href")||i.getAttribute("href");if("stylesheet"===i.rel&&(r===n||r===e))return i}var o=document.getElementsByTagName("style");for(a=0;a<o.length;a++){i=o[a],r=i.getAttribute("data-href");if(r===n||r===e)return i}},a=function(a){return new Promise((function(i,r){var o=t.miniCssF(a),s=t.p+o;if(e(o,s))return i();n(a,s,i,r)}))},i={143:0};t.f.miniCss=function(n,e){var t={18:1,162:1,463:1,534:1,840:1};i[n]?e.push(i[n]):0!==i[n]&&t[n]&&e.push(i[n]=a(n).then((function(){i[n]=0}),(function(e){throw delete i[n],e})))}}(),function(){t.b=document.baseURI||self.location.href;var n={143:0};t.f.j=function(e,a){var i=t.o(n,e)?n[e]:void 0;if(0!==i)if(i)a.push(i[2]);else{var r=new Promise((function(t,a){i=n[e]=[t,a]}));a.push(i[2]=r);var o=t.p+t.u(e),s=new Error,m=function(a){if(t.o(n,e)&&(i=n[e],0!==i&&(n[e]=void 0),i)){var r=a&&("load"===a.type?"missing":a.type),o=a&&a.target&&a.target.src;s.message="Loading chunk "+e+" failed.\n("+r+": "+o+")",s.name="ChunkLoadError",s.type=r,s.request=o,i[1](s)}};t.l(o,m,"chunk-"+e,e)}},t.O.j=function(e){return 0===n[e]};var e=function(e,a){var i,r,o=a[0],s=a[1],m=a[2],d=0;if(o.some((function(e){return 0!==n[e]}))){for(i in s)t.o(s,i)&&(t.m[i]=s[i]);if(m)var u=m(t)}for(e&&e(a);d<o.length;d++)r=o[d],t.o(n,r)&&n[r]&&n[r][0](),n[r]=0;return t.O(u)},a=self["webpackChunkmirage_tank_images"]=self["webpackChunkmirage_tank_images"]||[];a.forEach(e.bind(null,0)),a.push=e.bind(null,a.push.bind(a))}();var a=t.O(void 0,[998],(function(){return t(719)}));a=t.O(a)})();
//# sourceMappingURL=app.4c006bc4.js.map